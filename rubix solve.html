<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Rubik's Cube Solver</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #ui { position: fixed; top: 10px; left: 10px; z-index: 10; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 8px; }
    button { margin: 5px; padding: 10px; font-size: 14px; }
    #solution { margin-top: 10px; white-space: pre-wrap; font-weight: bold; }
  </style>
</head>
<body>
  <div id="ui">
    <button onclick="previousFace()">⬅ Previous</button>
    <button onclick="nextFace()">Next ➡</button>
    <button onclick="solveCube()">Solve ✅</button>
    <p id="faceLabel">Face: Up</p>
    <div id="solution"></div>
  </div>
  <canvas id="cubeCanvas"></canvas>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <!-- CubeJS solver -->
  <script src="https://cdn.jsdelivr.net/npm/cubejs/lib/cubejs.min.js"></script>

  <script>
    const canvas = document.getElementById("cubeCanvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(5, 5, 7);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Face names (same order cubejs expects: U, R, F, D, L, B)
    const faceNames = ["Up", "Right", "Front", "Down", "Left", "Back"];
    let currentFace = 0;
    const faceLabel = document.getElementById("faceLabel");

    const stickers = [];
    const stickerSize = 0.95;
    const gap = 0.05;

    function createCube() {
      const cubeGroup = new THREE.Group();
      const stickerGeometry = new THREE.PlaneGeometry(stickerSize, stickerSize);

      const offsets = [-1, 0, 1];
      for (let x of offsets) {
        for (let y of offsets) {
          for (let z of offsets) {
            if (Math.abs(x) + Math.abs(y) + Math.abs(z) === 3) {
              const sticker = new THREE.Mesh(
                stickerGeometry,
                new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
              );
              sticker.position.set(x + x*gap, y + y*gap, z + z*gap);
              sticker.lookAt(sticker.position.clone().multiplyScalar(2));
              scene.add(sticker);
              stickers.push(sticker);
            }
          }
        }
      }
    }

    createCube();

    // Raycaster for picking
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(stickers);
      if (intersects.length > 0) {
        const sticker = intersects[0].object;
        const colors = [0xffffff, 0xff0000, 0x00ff00, 0xffff00, 0xffa500, 0x0000ff];
        const letters = ["U", "R", "F", "D", "L", "B"]; // mapping to cubejs
        let current = colors.findIndex(c => c === sticker.material.color.getHex());
        sticker.material.color.setHex(colors[(current + 1) % colors.length]);
        sticker.userData.letter = letters[(current + 1) % letters.length];
      }
    }
    window.addEventListener("click", onClick);

    function nextFace() {
      currentFace = (currentFace + 1) % 6;
      faceLabel.innerText = "Face: " + faceNames[currentFace];
    }

    function previousFace() {
      currentFace = (currentFace - 1 + 6) % 6;
      faceLabel.innerText = "Face: " + faceNames[currentFace];
    }

    function solveCube() {
      const state = stickers.map(s => s.userData.letter || "U").join("");
      try {
        const solution = cubejs.solve(state);
        document.getElementById("solution").innerText = "Solution:\n" + solution;
      } catch (e) {
        document.getElementById("solution").innerText = "❌ Invalid cube state. Make sure all faces are filled correctly.";
      }
    }

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,5,5);
    scene.add(light);

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
