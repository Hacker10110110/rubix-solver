<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Rubik's Cube Input</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #ui { position: fixed; top: 10px; left: 10px; z-index: 10; }
    button { margin: 5px; padding: 10px; font-size: 16px; }
  </style>
</head>
<body>
  <div id="ui">
    <button onclick="previousFace()">⬅ Previous</button>
    <button onclick="nextFace()">Next ➡</button>
    <p id="faceLabel">Face: Up</p>
  </div>
  <canvas id="cubeCanvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Setup renderer & scene
    const canvas = document.getElementById("cubeCanvas");
    const renderer = new THREE.WebGLRenderer({ canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(4, 4, 6);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Cube face colors
    const faceNames = ["Up", "Right", "Front", "Down", "Left", "Back"];
    let currentFace = 0;

    const faceLabel = document.getElementById("faceLabel");

    // Create Rubik’s cube stickers (3x3x3 cube representation)
    const stickers = [];
    const stickerSize = 0.95;
    const gap = 0.05;

    function createCube() {
      const cubeGroup = new THREE.Group();
      const stickerGeometry = new THREE.PlaneGeometry(stickerSize, stickerSize);

      const offsets = [-1, 0, 1];
      for (let x of offsets) {
        for (let y of offsets) {
          for (let z of offsets) {
            // Only surface stickers
            if (Math.abs(x) + Math.abs(y) + Math.abs(z) === 3) {
              const sticker = new THREE.Mesh(stickerGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
              sticker.position.set(x + x*gap, y + y*gap, z + z*gap);
              sticker.lookAt(sticker.position.clone().multiplyScalar(2));
              cubeGroup.add(sticker);
              stickers.push(sticker);
            }
          }
        }
      }
      return cubeGroup;
    }

    const cube = createCube();
    scene.add(cube);

    // Raycaster for picking stickers
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(stickers);
      if (intersects.length > 0) {
        const sticker = intersects[0].object;
        // Cycle through colors
        const colors = [0xffffff, 0xff0000, 0x00ff00, 0xffff00, 0xffa500, 0x0000ff];
        let current = colors.findIndex(c => c === sticker.material.color.getHex());
        sticker.material.color.setHex(colors[(current + 1) % colors.length]);
      }
    }
    window.addEventListener("click", onClick);

    function nextFace() {
      currentFace = (currentFace + 1) % 6;
      faceLabel.innerText = "Face: " + faceNames[currentFace];
    }

    function previousFace() {
      currentFace = (currentFace - 1 + 6) % 6;
      faceLabel.innerText = "Face: " + faceNames[currentFace];
    }

    // Lighting
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,5,5);
    scene.add(light);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
